### [221103 ←](/221011-_JAVA/221103/) | *→ 221107*<!--(/221011-_JAVA/221107/)-->

# 이날 배웠던 것

- [메서드 연습 7억 2천만번째](/221011-_JAVA/221104/javastudy56/javastudy/src/javastudy/Object10.java): Object10.java
- [메서드 연습 114억 514만번째](/221011-_JAVA/221104/javastudy56/javastudy/src/javastudy/Object11.java): Object11.java
- [클래스 기본, 생성자](/221011-_JAVA/221104/javastudy56/javastudy/src/javastudy/Object12_sub.java): Object12_sub.java
    - [클래스 객체 만들어보기](/221011-_JAVA/221104/javastudy56/javastudy/src/javastudy/Object12.java): Object12.java

---

## 클래스 진도 나가 "줘"

- 클래스는 메서드와 필드의 집합
    - 클래스 안에서 정의된 내부 변수를 필드라고 합니다.
- 앞으로 클래스를 엄청나게 많이 만들게 된다.
    - 왜? 필요한 기능이 있으면 직접 설계해서 만들어야 하기 때문이다.
    - 설령 간단한 기능일지라도 말이다.
        - *총합이나 평균 같은 건 뭔가 수학 관련 클래스를 불러오면 계산해 줄 것 같기도 한데 말이죠. 하지만 직접 설계해서 만들어 보는 것만큼 코딩에서 중요한 건 없기 때문에, 없다고 하신 듯합니다.*

## 생성자

- 클래스랑 이름이 **토씨 하나 안 틀리고 완전히** 똑같다.
- 리턴 타입이 없다.
- `Car c = new Car();`라고 하면 `Car` 클래스 안에 있는 `public Car() {}` 생성자를 실행시키는 역할을 한다는 것.
    - 일단 그냥 그런가보다 하자.
- 어떠한 클래스던 간에 일단 기본 `Car()`라는 생성자는 존재한다.
- 근데 만약에 생성자에서 `public Car(String s) {}`라고 하면 기본 생성자를 **오버라이드**해서 문자열을 받는 생성자로 바뀌게 된다.
    - *자바의 경우, 모든 클래스의 부모 클래스인 `Object`가 존재하고, 이 클래스의 생성자가 존재하기 때문에 그렇습니다. 상속받은 자식 클래스에서 생성자나 메서드를 재정의하여 덮어쓰는 것을 ***오버라이드***라고 합니다.*
    - `Car()`도 걍 받고 싶다면, 그걸 직접 타이핑해 줘야 한다.