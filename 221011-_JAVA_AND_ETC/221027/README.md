# 이날 배웠던 것

- [정수 배열과 그 배열을 오름차순 내지는 내림차순으로 정렬하는 방법에 대한 실습](/221011-_JAVA_AND_ETC/221027/javastudy56/javastudy/src/javastudy/Java31.java)

---

## [Java30.java](/221011-_JAVA_AND_ETC/221026/javastudy56/javastudy/src/javastudy/Java30.java)를 좀 복습해 보는 시간

- `int[] arr = new int[10];`으로 배열을 선언하자

    | `int` | `[]` | `arr` | `=` | `new` | `int` | `[10]` |
    |---|---|---|---|---|---|---|
    | 정수형 | 배열 | `arr` | 을 선언함 | 새로운 | 정수형 | 길이 `10`으로 |

- 메모리에 일어나는 일들
    - 일반적으로 `int a = 0;`같이 선언하면, 메모리 안에는 `a`라는 이름이 붙어 있는 상자에 `0`이라는 쪽지가 들어 있는 그림으로 공간이 생긴다.
        - 컴퓨터 메모리는 주소와 그 주소에 저장된 값의 쌍으로 구성되어 있는데, 64비트 시스템의 경우 `0x 0000 0000 0000 0000` 형식으로 16진수(2^4: 4비트) 16자리(8비트 * 8 = 64비트)의 메모리 주소를 가지고(*사실은 아닙니다만 개념 이해를 위해 그렇게 말씀드립니다*), 물리적으로 설치되어 있는 메모리의 용량 한계까지 주소와 그 주소에 저장되어 있는 데이터의 쌍이 가득 차 있다고 보면 된다.
        - 메모리 주소를 지정하는 방식은 CPU의 명령어 아키텍처에 따라 달라진다. 즉 코드에서 첫 번째 변수를 저장했다고 해서 그게 꼭 `0x00...1`에 저장되는 건 아니다. 하지만 이것 역시 편의를 위해 그냥 **`001`번 메모리**라는 식으로 말하는 거다.
        - 이러한 단순화를 거치고 나서, 다시 `a`라는 변수를 돌아보자.
    - `a`가 메모리 주소 `001`번을 가진다면, `001`번 주소에는 `0`이라는 값이 그대로 저장되어 있다.
    - 하지만 `int[] arr`은 좀 다르다.
        - `arr`을 `print()`등으로 직접 출력해서 보면, 이상한 16진수만 나온다.
        - 위의 예를 들어서 설명하자면, 일단 `arr`이 `001`번 메모리에 저장되는 건 맞다.
        - 근데 `001`번 주소에 찾아가면, `010`이라는, 메모리 주소를 가리키는 값만 있다는 것이다.
        - 그리고 `010`번 주소에 찾아가면 그 뒤의 `011`번 부터 `01A`번 주소까지, 배열의 길이에 해당하는 10개의 주소에 각각의 배열 성분들이 저장되어 있다는 말이다.

## 배열 정렬에 대한 고찰

- `i = 0`일 경우
    - `j = 0`일 땐 조건 안 맞음,
    - `j = 1`일 땐 `arr[0]` = 21 < 64 = `arr[1]`이므로 조건 안 맞음,
    - ......
    - `j = 5`일 땐 21 > 14 = `arr[5]`이므로 조건이 맞음
        - 그러면 두 개의 자리가 바뀌어 결과적으로 배열은 `{14, ... , 21, ...}`이 됨
    - `j = 7`일 때 한 번 더 조건이 맞음(14 > 10), `i`는 아직도 `0`임
        - `0`번과 `7`번 자리가 바뀌면 배열은 `{10, ... , 21, 62, 14, ...}`이 됨
    - 맨 앞의 숫자(`arr[0]`)와 뒤의 숫자(`arr[j]`)를 비교해서 뒤의 숫자(`arr[j]`)가 작으면 그 숫자(`arr[j]`)가 맨 앞으로 온다
        - 그리고 그 맨 앞(`arr[j]`)보다 그 뒤의 숫자(`arr[j']`)가 더 작으면 또 그 숫자(`arr[j']`)가 맨 앞으로 온다
        - 이것을 배열의 끝(`arr[arr.length - 1]`)까지 계속하면 결국은 제일 작은 숫자가 맨 앞에 온 채로 반복문이 종료된다
    - 비교가 끝나고 나면 `arr[i]`, 즉 `arr[0]`에는 그 배열에서 가장 작은 숫자가 온다.

- `i = 1`일 경우 
    - `arr[0]`을 빼고 `arr[1]`을 '맨 앞'으로 삼아서 같은 일을 한다.
    - 그렇다면 `arr[0]`은 바뀌지 않은 채로, 나머지 뒤에서 제일 작은 숫자가 `arr[1]`에 오게 된다.
    - 즉 `arr`은 `{제일 작은 숫자, 그 다음으로 작은 숫자, 무작무작위 ... }` 이렇게 된 채로 `i = 2`로 접어들 것이다.

- `i = 2`일 경우
    - `arr[2]` 자리에, 제일 작은 숫자와 두 번쨰로 작은 숫자를 제외한 나머지 배열에서 가장 작은 수, 즉 세 번째로 작은 숫자를 놓게 된다.
    - 그럼 `i = 2`인 시점에서 arr은 아래와 같이 될 것이다: `{제일 작은 숫자, 두 번째로 작은 숫자, 세 번째로 작은 숫자, 무작무작 ... }`

- `i = 3`일 경우
    - 이제 `arr[0]`과 `arr[1]`, `arr[2]`가 결정된 상태에서 `arr[3]`에 놓일 수를 또 `for`문으로 결정한다.
    - 그럼 이제 대충 눈치가 채지겠지만, 0번부터 3번 자리까지 오름차순으로 숫자가 정렬된다.
    - `arr = {젤 작은, 두 번째, 세 번째, 네 번째, 무작무작작 ... }`

- 그렇게 `i = arr.length - 1`(`i < arr.length`인 마지막 정수)까지 반복하면 당연히, 각자의 자리에 그 자리 번호만큼 큰 숫자가 오게 된다. 오름차순으로 정렬이 된 채로 배열이 바뀌어 있다는 것.

- 이제 다시 한 번 [Java31.java](/221011-_JAVA_AND_ETC/221027/javastudy56/javastudy/src/javastudy/Java31.java)를 보자. 그리고 `i`값과 `j`값, 그리고 그것이 `arr`에 끼치는 영향에 대해서 생각해 보자.

## 대체 이 머리 터지는 경험을 왜 하는가?

- 자꾸 해버릇해야 무슨 변수가 언제 어떻게 변하는지 추적할 수 있다.
- 그리고 그 추적능력이 코드를 읽는 능력이고, 추적을 바탕으로 새로운 코드를 쓰는 것이 코딩 실력이란 것이다.
- 머리도 계속 터지다 보면 고통이 좀 덜할 것이다.
- *근데 진지하게 좀 재밌지 않아요? 좀 퍼즐 푸는 기분이고 막... 사실 중첩 `for`문 그다지 잘 쓰지도 않는데 수많은 괄호 안에서 변수가 어떻게 변하는지는 정말 매일매일 밥 먹듯이 할 거기 때문에... 계속 머리가 자극되고 새로운 걸 써야 하다 보니까 치매예방엔 직빵인 직업이 되겠습니다.*